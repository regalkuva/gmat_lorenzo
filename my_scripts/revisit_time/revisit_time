## REVISIT TIME CALCULATOR ON A SPECIFIC LOCATION ON EARTH

from astropy import units as u
from astropy.time import Time, TimeDelta
from astropy import coordinates as coord
# from astropy.coordinates import EarthLocation, WGS84GeodeticRepresentation

from poliastro.bodies import Earth
from poliastro.twobody import Orbit
from poliastro.twobody.sampling import EpochsArray
from poliastro.twobody.propagation import CowellPropagator
from poliastro.util import Time, time_range
from poliastro.plotting import OrbitPlotter2D
from poliastro.earth import EarthSatellite, Spacecraft
from poliastro.earth.plotting import GroundtrackPlotter

from haversine import haversine

import numpy as np
import pandas as pd
import time

import plotly.graph_objects as go
import matplotlib.pyplot as plt

process_start_time = time.time()   # start time of python code
start_date_time = time.ctime()  # start time of python code
print(f'\nREVISIT TIME FOR A SPECIFIC LOCATION ON EARTH --- [process start: {start_date_time}]\n')

# initial orbital elements
alt  = 380 * u.km
a    = (Earth.R).to(u.km) + alt
ecc  = 0.001 * u.one
inc  = 96.9172647751491 * u.deg
raan = 0 * u.deg
argp = 0 * u.deg
nu   = 0 * u.deg 

start_date = Time("2023-01-01 00:00:00.000", scale = "utc")   # epoch

# sensor parameters
sw = 50*0.5 # [km]

# 25 km --> 0.22483 deg of latitude

targets_coord = {'Naples': (40.8518, 14.2681), 'Helsinki': (60.1699, 24.9384)}

# target = targets_coord['Helsinki']   # latitude/longitude [deg]

# Definition of the initial orbit (poliastro)
in_orbit = Orbit.from_classical(Earth, a, ecc, inc, raan, argp, nu, start_date)

# Spacecraft data
C_D = 2.2  * u.one
A   = 0.01 * u.m**2
m   = 2.5  * u.kg

rhw_sc = Spacecraft(A, C_D, m)

# Keplerian two-body propagation (poliastro)
time_frame = 7 * u.day   #float(input('Time frame [days]: '))
time_step  = 1 * u.s     #float(input('Time step [sec]: '))

number = int(time_frame.to_value(u.s) / time_step.value)
tofs = TimeDelta(np.linspace(0, time_frame, num=number))
t_span = time_range(start=start_date, periods=number, end=start_date + time_frame)



ephems = in_orbit.to_ephem(EpochsArray(start_date + tofs, CowellPropagator(rtol=1e-5)))

# xyz_0  = in_orbit.represent_as(coord.CartesianRepresentation)
# gcrs_0 = coord.GCRS(xyz_0, obstime=start_date)
# itrs_0 = gcrs_0.transform_to(coord.ITRS(obstime=start_date))
# loc_0  = coord.EarthLocation.from_geocentric(itrs_0.x, itrs_0.y, itrs_0.z)
# lon_0, lat_0, _ = loc_0.to_geodetic()
# target = (lat_0.value, lon_0.value)

target = targets_coord['Naples']

access_time = []
revisit_time = []

i = 0
j = 0

while len(revisit_time) == 0:
    curr_orbit = Orbit.from_ephem(Earth, ephems, ephems.epochs[i])

    xyz  = curr_orbit.represent_as(coord.CartesianRepresentation)
    gcrs = coord.GCRS(xyz, obstime=ephems.epochs[i])
    itrs = gcrs.transform_to(coord.ITRS(obstime=ephems.epochs[i]))
    loc  = coord.EarthLocation.from_geocentric(itrs.x, itrs.y, itrs.z)
     
    lon, lat, _ = loc.to_geodetic()
    pos = (lat.value, lon.value)
    dist = haversine(pos, target)
    print(dist)

    if  dist < sw:
        access_time.append(ephems.epochs[i])
    
        if (len(access_time)>1) and (((access_time[j].jd - access_time[j-1].jd)) > ((5*u.s).to_value(u.day))):
            revisit_time.append(access_time[j].jd - access_time[j-1].jd)

        j += 1

    i += 1

print(f'\nRevisit time = {revisit_time} s\n')
print(f'\nProcess finished --- {int(time.time() - process_start_time)}')



# for idx in range(len(rvec)):
    
#     curr_orbit = Orbit.from_ephem(Earth, ephems, ephems.epochs[idx])
#     lat = (curr_orbit.represent_as(SphericalRepresentation).lat).to_value(u.deg)
#     lon = (curr_orbit.represent_as(SphericalRepresentation).lon).to_value(u.deg)
    
#     if lon > 180:
#         lon = lon - 360

#     pos = (lat, lon)
#     dist = haversine(pos, target)

#     if  dist < sw:
#         access_time.append(ephems.epochs[idx])
    
#         if (len(access_time)>1) and (((access_time[i].jd - access_time[i-1].jd)) > ((time_step*2).to_value(u.day))):
#             revisit_time.append(access_time[i].jd - access_time[i-1].jd)

#         i += 1


# print(revisit_time)




# ground-track plot
# rhw = EarthSatellite(in_orbit, rhw_sc)
# t_span = time_range(start=start_date, periods=150, end=start_date + revisit_time * 2)

# gt = GroundtrackPlotter()
# gt.plot(rhw, t_span, label='RHW', color='red')
# gt.add_trace(go.Scattergeo(lat=target[0]*u.deg, lon=target[1]*u.deg, name='Naples', marker={'color': 'blue'}))
# gt.fig.show()

# lat = (np.arctan2(rvec[idx][2], np.sqrt(rvec[idx][0]**2 + rvec[idx][1]**2))) * u.rad
# lon = (np.arctan2(rvec[idx][1], rvec[idx][0])) * u.rad